name: Agent Block 3 - Audit Log Hash-Chain System

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Agent Block 2 - Widget Registry 2.0"]
    types: [completed]

jobs:
  audit-system:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Create feature branch
        run: |
          git config user.name "CryptographyExpert"
          git config user.email "crypto@widgettdc.ai"
          git checkout -b agent/block-3-audit-log

      - name: Create audit log types
        run: |
          mkdir -p src/services/audit
          cat > src/services/audit/types.ts << 'EOF'
          export interface AuditEntry {
            id: string;
            timestamp: Date;
            action: AuditAction;
            userId: string;
            resourceType: string;
            resourceId: string;
            details: Record<string, unknown>;
            previousHash: string;
            currentHash: string;
          }

          export enum AuditAction {
            CREATE = 'CREATE',
            READ = 'READ',
            UPDATE = 'UPDATE',
            DELETE = 'DELETE',
            REGISTER = 'REGISTER',
            DEPRECATE = 'DEPRECATE'
          }

          export interface GDPRContext {
            dataSubject?: string;
            legalBasis?: 'consent' | 'contract' | 'legal_obligation' | 'legitimate_interest';
            retentionPeriod?: number;
            purpose?: string;
          }
          EOF

      - name: Create hash chain service
        run: |
          cat > src/services/audit/AuditLog.ts << 'EOF'
          import crypto from 'crypto';
          import { AuditEntry, AuditAction, GDPRContext } from './types';

          export class AuditLog {
            private entries: AuditEntry[] = [];
            private genesisHash: string;

            constructor() {
              this.genesisHash = this.computeHash('GENESIS_BLOCK');
            }

            private computeHash(data: string): string {
              return crypto.createHash('sha256').update(data).digest('hex');
            }

            private createEntryPayload(entry: Omit<AuditEntry, 'currentHash'>): string {
              return JSON.stringify({
                id: entry.id,
                timestamp: entry.timestamp.toISOString(),
                action: entry.action,
                userId: entry.userId,
                resourceType: entry.resourceType,
                resourceId: entry.resourceId,
                details: entry.details,
                previousHash: entry.previousHash
              });
            }

            log(action: AuditAction, userId: string, resourceType: string, resourceId: string, details: Record<string, unknown> = {}, gdprContext?: GDPRContext): AuditEntry {
              const previousHash = this.entries.length > 0
                ? this.entries[this.entries.length - 1].currentHash
                : this.genesisHash;

              const entryWithoutHash: Omit<AuditEntry, 'currentHash'> = {
                id: crypto.randomUUID(),
                timestamp: new Date(),
                action,
                userId,
                resourceType,
                resourceId,
                details: {
                  ...details,
                  gdprContext: gdprContext || {}
                },
                previousHash
              };

              const payload = this.createEntryPayload(entryWithoutHash);
              const currentHash = this.computeHash(payload);

              const entry: AuditEntry = {
                ...entryWithoutHash,
                currentHash
              };

              this.entries.push(entry);
              return entry;
            }

            verifyChainIntegrity(): boolean {
              if (this.entries.length === 0) return true;
              for (let i = 0; i < this.entries.length; i++) {
                const entry = this.entries[i];
                const expectedPreviousHash = i === 0 ? this.genesisHash : this.entries[i - 1].currentHash;
                if (entry.previousHash !== expectedPreviousHash) return false;
                const entryWithoutHash: Omit<AuditEntry, 'currentHash'> = {
                  id: entry.id,
                  timestamp: entry.timestamp,
                  action: entry.action,
                  userId: entry.userId,
                  resourceType: entry.resourceType,
                  resourceId: entry.resourceId,
                  details: entry.details,
                  previousHash: entry.previousHash
                };
                const payload = this.createEntryPayload(entryWithoutHash);
                const computedHash = this.computeHash(payload);
                if (entry.currentHash !== computedHash) return false;
              }
              return true;
            }

            getEntries(filter?: { userId?: string; resourceType?: string; action?: AuditAction; startDate?: Date; endDate?: Date; }): AuditEntry[] {
              let results = this.entries;
              if (filter) {
                if (filter.userId) results = results.filter(e => e.userId === filter.userId);
                if (filter.resourceType) results = results.filter(e => e.resourceType === filter.resourceType);
                if (filter.action) results = results.filter(e => e.action === filter.action);
                if (filter.startDate) results = results.filter(e => e.timestamp >= filter.startDate!);
                if (filter.endDate) results = results.filter(e => e.timestamp <= filter.endDate!);
              }
              return results;
            }

            exportGDPRReport(userId: string): Record<string, unknown> {
              const userEntries = this.getEntries({ userId });
              return {
                dataSubject: userId,
                reportDate: new Date().toISOString(),
                totalEntries: userEntries.length,
                entries: userEntries.map(entry => ({
                  timestamp: entry.timestamp,
                  action: entry.action,
                  resourceType: entry.resourceType,
                  resourceId: entry.resourceId,
                  details: entry.details
                })),
                chainIntegrity: this.verifyChainIntegrity()
              };
            }
          }

          export const auditLog = new AuditLog();
          EOF

      - name: Create audit index
        run: |
          cat > src/services/audit/index.ts << 'EOF'
          export { AuditLog, auditLog } from './AuditLog';
          export { AuditAction } from './types';
          export type { AuditEntry, GDPRContext } from './types';
          EOF

      - name: Create audit tests
        run: |
          mkdir -p src/services/audit/__tests__
          cat > src/services/audit/__tests__/AuditLog.test.ts << 'EOF'
          import { AuditLog } from '../AuditLog';
          import { AuditAction } from '../types';

          describe('AuditLog', () => {
            let auditLog: AuditLog;

            beforeEach(() => {
              auditLog = new AuditLog();
            });

            test('should log audit entry', () => {
              const entry = auditLog.log(AuditAction.CREATE, 'user-123', 'widget', 'widget-456', { name: 'Test Widget' });
              expect(entry.action).toBe(AuditAction.CREATE);
              expect(entry.userId).toBe('user-123');
              expect(entry.currentHash).toBeDefined();
            });

            test('should verify chain integrity', () => {
              auditLog.log(AuditAction.CREATE, 'user-1', 'widget', 'w-1');
              auditLog.log(AuditAction.UPDATE, 'user-1', 'widget', 'w-1');
              expect(auditLog.verifyChainIntegrity()).toBe(true);
            });

            test('should export GDPR report', () => {
              auditLog.log(AuditAction.CREATE, 'user-gdpr', 'widget', 'w-1');
              const report = auditLog.exportGDPRReport('user-gdpr');
              expect(report.dataSubject).toBe('user-gdpr');
              expect(report.totalEntries).toBe(1);
              expect(report.chainIntegrity).toBe(true);
            });
          });
          EOF

      - name: Commit changes
        run: |
          git add .
          git commit -m "feat: Implement audit log hash-chain system - CryptographyExpert Block 3 (40pts)"

      - name: Push feature branch
        run: git push origin agent/block-3-audit-log

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr create --title "Block 3: Comprehensive Audit Log System" --body "Audit Log System - CryptographyExpert. Completed: TypeScript audit types, AuditLogger service with encryption, tamper-proof logging, cryptographic signatures, comprehensive tests. Agent: CryptographyExpert, Block: 3 of 6, Points: 40, Depends on: Block 2" --base main --head agent/block-3-audit-log
