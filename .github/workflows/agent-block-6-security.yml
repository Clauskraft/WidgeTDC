name: Agent Block 6 - SecurityCompliance

on:
  workflow_run:
    workflows: ["Agent Block 5 - QASpecialist"]
    types:
      - completed
  workflow_dispatch:

env:
  AGENT_NAME: SecurityCompliance
  BLOCK_NUMBER: 6
  STORY_POINTS: 28

jobs:
  security-scanning:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          git config user.name "SecurityCompliance Agent"
          git config user.email "security@widgettdc.dev"

      - name: Create feature branch
        run: |
          BRANCH_NAME="agent/block-6-security-compliance"
          git checkout -b $BRANCH_NAME
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Create security directory structure
        run: |
          mkdir -p security/policies
          mkdir -p security/scans
          mkdir -p security/reports
          mkdir -p .github/workflows/security
          echo "Security directories created"

      - name: Create security policy
        run: |
          cat > SECURITY.md << 'EOF'
          # Security Policy

          ## Supported Versions

          | Version | Supported          |
          | ------- | ------------------ |
          | 1.x     | :white_check_mark: |
          | < 1.0   | :x:                |

          ## Reporting a Vulnerability

          Please report security vulnerabilities to security@widgettdc.dev

          We will respond within 48 hours and provide a timeline for fixes.

          ## Security Measures

          - All passwords are hashed using bcrypt
          - JWT tokens with 24-hour expiration
          - SQL injection prevention via parameterized queries
          - XSS protection with input sanitization
          - CSRF tokens on all state-changing operations
          - Rate limiting on authentication endpoints
          - Security headers (HSTS, CSP, X-Frame-Options)

          ## Dependency Management

          Dependencies are scanned weekly for known vulnerabilities.
          Critical vulnerabilities are patched within 24 hours.
          EOF

      - name: Create CodeQL workflow
        run: |
          cat > .github/workflows/security/codeql-analysis.yml << 'EOF'
          name: CodeQL Security Scan

          on:
            push:
              branches: [ main, develop ]
            pull_request:
              branches: [ main ]
            schedule:
              - cron: '0 2 * * 1'

          jobs:
            analyze:
              name: Analyze
              runs-on: ubuntu-latest

              strategy:
                matrix:
                  language: [ 'javascript' ]

              steps:
                - name: Checkout repository
                  uses: actions/checkout@v4

                - name: Initialize CodeQL
                  uses: github/codeql-action/init@v3
                  with:
                    languages: ${{ matrix.language }}

                - name: Autobuild
                  uses: github/codeql-action/autobuild@v3

                - name: Perform CodeQL Analysis
                  uses: github/codeql-action/analyze@v3
          EOF

      - name: Create dependency scanning workflow
        run: |
          cat > .github/workflows/security/dependency-scan.yml << 'EOF'
          name: Dependency Security Scan

          on:
            push:
              branches: [ main ]
            pull_request:
              branches: [ main ]
            schedule:
              - cron: '0 3 * * *'

          jobs:
            scan:
              runs-on: ubuntu-latest

              steps:
                - uses: actions/checkout@v4

                - name: Run npm audit
                  run: npm audit --audit-level=moderate

                - name: Run Snyk test
                  uses: snyk/actions/node@master
                  env:
                    SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
                  with:
                    command: test
                    args: --severity-threshold=high
          EOF

      - name: Create security headers middleware
        run: |
          cat > src/middleware/securityHeaders.js << 'EOF'
          const helmet = require('helmet');

          const securityHeaders = helmet({
            contentSecurityPolicy: {
              directives: {
                defaultSrc: ["'self'"],
                styleSrc: ["'self'", "'unsafe-inline'"],
                scriptSrc: ["'self'"],
                imgSrc: ["'self'", "data:", "https:"],
                connectSrc: ["'self'"],
                fontSrc: ["'self'"],
                objectSrc: ["'none'"],
                mediaSrc: ["'self'"],
                frameSrc: ["'none'"]
              }
            },
            hsts: {
              maxAge: 31536000,
              includeSubDomains: true,
              preload: true
            },
            referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
            noSniff: true,
            xssFilter: true,
            hidePoweredBy: true
          });

          module.exports = securityHeaders;
          EOF

      - name: Create rate limiting middleware
        run: |
          cat > src/middleware/rateLimiter.js << 'EOF'
          const rateLimit = require('express-rate-limit');
          const RedisStore = require('rate-limit-redis');
          const redis = require('redis');

          const redisClient = redis.createClient({
            host: process.env.REDIS_HOST || 'localhost',
            port: process.env.REDIS_PORT || 6379
          });

          const createRateLimiter = (options = {}) => {
            return rateLimit({
              store: new RedisStore({
                client: redisClient,
                prefix: 'rl:'
              }),
              windowMs: options.windowMs || 15 * 60 * 1000,
              max: options.max || 100,
              message: options.message || 'Too many requests, please try again later',
              standardHeaders: true,
              legacyHeaders: false
            });
          };

          const authLimiter = createRateLimiter({
            windowMs: 15 * 60 * 1000,
            max: 5,
            message: 'Too many authentication attempts, please try again later'
          });

          const apiLimiter = createRateLimiter({
            windowMs: 15 * 60 * 1000,
            max: 100
          });

          module.exports = { authLimiter, apiLimiter, createRateLimiter };
          EOF

      - name: Create input validation middleware
        run: |
          cat > src/middleware/inputValidation.js << 'EOF'
          const { validationResult } = require('express-validator');
          const sanitizeHtml = require('sanitize-html');

          const validate = (req, res, next) => {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
              return res.status(400).json({ errors: errors.array() });
            }
            next();
          };

          const sanitizeInput = (input) => {
            if (typeof input === 'string') {
              return sanitizeHtml(input, {
                allowedTags: [],
                allowedAttributes: {}
              });
            }
            if (typeof input === 'object' && input !== null) {
              const sanitized = {};
              for (const key in input) {
                sanitized[key] = sanitizeInput(input[key]);
              }
              return sanitized;
            }
            return input;
          };

          const sanitizeBody = (req, res, next) => {
            if (req.body) {
              req.body = sanitizeInput(req.body);
            }
            next();
          };

          const sanitizeQuery = (req, res, next) => {
            if (req.query) {
              req.query = sanitizeInput(req.query);
            }
            next();
          };

          module.exports = { validate, sanitizeBody, sanitizeQuery };
          EOF

      - name: Create CSRF protection middleware
        run: |
          cat > src/middleware/csrfProtection.js << 'EOF'
          const csrf = require('csurf');

          const csrfProtection = csrf({
            cookie: {
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'strict'
            }
          });

          const injectCsrfToken = (req, res, next) => {
            res.locals.csrfToken = req.csrfToken();
            next();
          };

          module.exports = { csrfProtection, injectCsrfToken };
          EOF

      - name: Create security audit script
        run: |
          cat > security/scans/audit.js << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');

          class SecurityAuditor {
            constructor() {
              this.results = {
                timestamp: new Date().toISOString(),
                vulnerabilities: [],
                summary: {}
              };
            }

            runNpmAudit() {
              try {
                const output = execSync('npm audit --json', { encoding: 'utf-8' });
                const auditData = JSON.parse(output);

                this.results.vulnerabilities.push(...auditData.vulnerabilities);
                this.results.summary.npm = {
                  total: auditData.metadata.vulnerabilities.total,
                  critical: auditData.metadata.vulnerabilities.critical,
                  high: auditData.metadata.vulnerabilities.high,
                  moderate: auditData.metadata.vulnerabilities.moderate,
                  low: auditData.metadata.vulnerabilities.low
                };
              } catch (error) {
                console.error('npm audit failed:', error.message);
              }
            }

            checkSecurityHeaders() {
              const required = [
                'helmet',
                'express-rate-limit',
                'csurf',
                'sanitize-html'
              ];

              const packageJson = require('../../package.json');
              const missing = required.filter(
                pkg => !packageJson.dependencies[pkg] && !packageJson.devDependencies[pkg]
              );

              this.results.summary.securityPackages = {
                required,
                missing,
                installed: required.length - missing.length
              };
            }

            generateReport() {
              const reportPath = path.join(__dirname, '../reports/audit-report.json');
              fs.writeFileSync(reportPath, JSON.stringify(this.results, null, 2));

              console.log('Security Audit Report:');
              console.log(JSON.stringify(this.results.summary, null, 2));

              return this.results;
            }

            run() {
              console.log('Running security audit...');
              this.runNpmAudit();
              this.checkSecurityHeaders();
              return this.generateReport();
            }
          }

          if (require.main === module) {
            const auditor = new SecurityAuditor();
            auditor.run();
          }

          module.exports = SecurityAuditor;
          EOF

      - name: Create security configuration
        run: |
          cat > security/policies/security-config.json << 'EOF'
          {
            "authentication": {
              "passwordMinLength": 12,
              "passwordRequireUppercase": true,
              "passwordRequireLowercase": true,
              "passwordRequireNumbers": true,
              "passwordRequireSymbols": true,
              "maxLoginAttempts": 5,
              "lockoutDurationMinutes": 30,
              "jwtExpirationHours": 24,
              "refreshTokenExpirationDays": 7
            },
            "rateLimiting": {
              "authEndpoints": {
                "windowMs": 900000,
                "maxRequests": 5
              },
              "apiEndpoints": {
                "windowMs": 900000,
                "maxRequests": 100
              }
            },
            "headers": {
              "hsts": true,
              "csp": true,
              "noSniff": true,
              "xssFilter": true,
              "hidePoweredBy": true
            },
            "inputValidation": {
              "sanitizeHtml": true,
              "maxBodySize": "10mb",
              "maxUrlLength": 2048
            },
            "audit": {
              "logFailedLogins": true,
              "logApiErrors": true,
              "logSecurityEvents": true
            }
          }
          EOF

      - name: Commit security infrastructure
        run: |
          git add .
          git commit -m "Agent: SecurityCompliance | Block: 6 | Points: 28

          Implement comprehensive security infrastructure

          - Created SECURITY.md policy document
          - CodeQL security scanning workflow
          - Dependency vulnerability scanning
          - Security headers middleware with Helmet
          - Rate limiting for auth and API endpoints
          - Input validation and sanitization
          - CSRF protection middleware
          - Automated security audit scripts
          - Security configuration policies

          Dependencies: Block 5 (QASpecialist)"

      - name: Push feature branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push origin $BRANCH_NAME

      - name: Create Pull Request
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr create \
            --title "Block 6: SecurityCompliance - Security Scanning (28 points)" \
            --body "## SecurityCompliance Agent - Block 6

          **Story Points:** 28
          **Agent:** SecurityCompliance
          **Block Number:** 6

          ### Implementation Summary
          Complete security infrastructure with scanning and protection

          ### Changes Made
          - SECURITY.md policy documentation
          - CodeQL and dependency scanning workflows
          - Security headers middleware (Helmet)
          - Rate limiting for authentication
          - Input validation and sanitization
          - CSRF protection
          - Automated security audit scripts
          - Security configuration policies

          ### Dependencies
          - Depends on: Block 5 (QASpecialist)
          - Final block in cascade

          Agent: SecurityCompliance | Block: 6 | Points: 28" \
            --base main \
            --head $BRANCH_NAME
