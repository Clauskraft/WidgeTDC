name: HansPedder Orchestrator (Self-Learning Cortex)

on:
  schedule:
    - cron: '0 * * * *' # Hver time
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:

env:
  ORCHESTRATOR_NAME: HansPedder
  AGENT_CONFIG: >-
    {
      "FrontendAgent": ["css", "style", "ui", "ux", "design", "html", "frontend", "tailwind", "button", "view", "react", "lucide"],
      "BackendAgent": ["api", "json", "server", "controller", "java", "c#", "route", "endpoint", "auth", "middleware"],
      "DataAgent": ["db", "sql", "database", "schema", "query", "postgres", "migration", "table", "column", "redis"],
      "DevOpsAgent": ["ci", "cd", "docker", "yaml", "cloud", "deploy", "build", "terraform", "pipeline", "action", "npm", "package"]
    }

jobs:
  orchestrate-system:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
      checks: read
      statuses: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          git config user.name "HansPedder Orchestrator"
          git config user.email "hanspedder@widgettdc.dev"

      - name: ğŸ§  HansPedder Cortex (Memory & Learning)
        id: orchestrate
        env:
          GH_TOKEN: ${{ github.token }}
          CONFIG: ${{ env.AGENT_CONFIG }}
          AI_API_KEY: ${{ secrets.AI_API_KEY }}
        shell: python
        run: |
          import json
          import os
          import re
          import subprocess
          import sys
          import urllib.request
          import time

          MEMORY_FILE = ".github/hanspedder_memory.json"

          # --- BASE FUNCTIONS ---
          def run_command(cmd):
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode != 0:
                      return None, result.stderr.strip()
                  return result.stdout.strip(), None
              except Exception as e:
                  return None, str(e)

          # --- MEMORY SYSTEM ---
          def load_memory():
              if os.path.exists(MEMORY_FILE):
                  try:
                      with open(MEMORY_FILE, 'r') as f:
                          return json.load(f)
                  except:
                      return {"fixes": []}
              return {"fixes": []}

          def save_to_memory(error_pattern, fix_command, context):
              mem = load_memory()
              # Tjek om vi allerede kender denne fix (for at undgÃ¥ dubletter)
              for entry in mem["fixes"]:
                  if entry["error"] == error_pattern:
                      return # Vi kender den allerede
              
              print(f"ğŸ§  LÃ†RING: Gemmer ny viden i hukommelsen: '{error_pattern}' -> '{fix_command}'")
              mem["fixes"].append({
                  "error": error_pattern,
                  "fix": fix_command,
                  "context": context,
                  "timestamp": time.time()
              })
              
              # Skriv til fil
              os.makedirs(os.path.dirname(MEMORY_FILE), exist_ok=True)
              with open(MEMORY_FILE, 'w') as f:
                  json.dump(mem, f, indent=2)
              
              # Commit hukommelsen til repoet sÃ¥ den huskes til nÃ¦ste gang
              run_command(["git", "add", MEMORY_FILE])
              run_command(["git", "commit", "-m", "chore(brain): HansPedder learned a new fix"])
              run_command(["git", "push", "origin", "main"])

          def recall_solution(error_msg):
              mem = load_memory()
              # Simpel fuzzy matching
              for entry in mem["fixes"]:
                  # Hvis en betydelig del af den gemte fejlbesked findes i den nuvÃ¦rende fejl
                  if entry["error"] in error_msg or error_msg in entry["error"]:
                      print(f"ğŸ’¡ HUKOMMELSE: Jeg har lÃ¸st dette fÃ¸r! Bruger gemt lÃ¸sning.")
                      return entry["fix"]
              return None

          # --- INTELLIGENCE CORE ---
          def consult_lifeline(error_msg, context="general"):
              print(f"\nğŸš‘ ANALYSERER FEJL I KONTEKST: {context}")
              
              # 1. TJEK HUKOMMELSE (SelvlÃ¦ring)
              known_fix = recall_solution(error_msg)
              if known_fix:
                  print(f"âš¡ UdfÃ¸rer kendt fix fra hukommelsen: {known_fix}")
                  out, err = run_command(known_fix.split())
                  if not err:
                      print("âœ… Fix virkede (baseret pÃ¥ erfaring).")
                      return True
                  else:
                      print("âš ï¸ Kendt fix virkede ikke denne gang. PrÃ¸ver AI...")

              # 2. OFFLINE HEURISTIK
              fixes = []
              if "index.lock" in error_msg: fixes.append(["rm", "-f", ".git/index.lock"])
              elif "shallow update" in error_msg: fixes.append(["git", "fetch", "--unshallow"])
              elif "conflict" in error_msg.lower(): fixes.append(["git", "merge", "--abort"])
              
              if fixes:
                  for fix_cmd in fixes:
                      out, err = run_command(fix_cmd)
                      if not err: return True

              # 3. ONLINE DEEPSEEK (Nyt fix)
              api_key = os.environ.get('AI_API_KEY')
              if not api_key: return False

              print("ğŸ“¡ SpÃ¸rger DeepSeek...")
              system_prompt = "You are a DevOps Expert. Return ONLY the single shell command needed to fix the error. No markdown. No explanation."
              user_prompt = f"Context: {context}. Error log: {error_msg}. Path: Repo root."
              
              payload = {
                  "model": "deepseek-chat",
                  "messages": [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}],
                  "temperature": 0.1,
                  "stream": False
              }

              try:
                  req = urllib.request.Request(
                      "https://api.deepseek.com/chat/completions",
                      data=json.dumps(payload).encode('utf-8'),
                      headers={"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                  )
                  with urllib.request.urlopen(req) as response:
                      resp_data = json.load(response)
                      ai_command = resp_data['choices'][0]['message']['content'].strip()
                      ai_command = ai_command.replace("```bash", "").replace("```", "").strip()

                      if "rm -rf /" in ai_command: return False # Sikkerhed

                      print(f"ğŸ¤– DeepSeek foreslÃ¥r: {ai_command}")
                      out, err = run_command(ai_command.split())
                      
                      if not err:
                          print("âœ… AI Fix udfÃ¸rt!")
                          # 4. GEM NY VIDEN I HUKOMMELSEN
                          # Vi gemmer de fÃ¸rste 100 tegn af fejlen som nÃ¸gle
                          short_error = error_msg[:200] if len(error_msg) > 200 else error_msg
                          save_to_memory(short_error, ai_command, context)
                          return True
                      else:
                          print(f"âŒ AI Fix fejlede: {err}")
                          return False
              except Exception as e:
                  print(f"ğŸ’¥ AI Fejl: {e}")
                  return False

          # --- MAIN LOOP ---
          try:
              print("ğŸ¤– HansPedder vÃ¥gner. Hukommelse indlÃ¦st.")
              agent_keywords = json.loads(os.environ['CONFIG'])
              orchestrator_name = "HansPedder"
              
              # === 1. PR MANAGEMENT ===
              print("\n--- 1. Analyserer Pull Requests ---")
              output, err = run_command(["gh", "pr", "list", "--state", "open", "--json", "number,title,body,author,headRefName"])
              if err and consult_lifeline(err, "PR List"): # PrÃ¸v at fixe hvis gh kommando fejler
                  output, err = run_command(["gh", "pr", "list", "--state", "open", "--json", "number,title,body,author,headRefName"])

              if output:
                  prs = json.loads(output)
                  for pr in prs:
                      try:
                          if pr['author']['login'] == "github-actions": continue 
                          number = pr['number']
                          title = pr['title']
                          body = pr['body'] if pr['body'] else ""
                          original_body = body
                          
                          print(f"Behandler PR #{number}: {title}")

                          # Allokering & Metadata (Standard)
                          agent_match = re.search(r'Agent:\s*([A-Za-z0-9_]+)', body)
                          current_agent = agent_match.group(1) if agent_match else None
                          if not current_agent:
                              # ... (Samme allokeringslogik som fÃ¸r) ...
                              best_agent = orchestrator_name
                              for name, keys in agent_keywords.items():
                                  if any(k in (title+body).lower() for k in keys): best_agent = name
                              current_agent = best_agent
                              body += f"\nAgent: {current_agent}"

                          if "Block:" not in body: body += "\nBlock: 99"
                          if "Points:" not in body: body += "\nPoints: 1"

                          if body != original_body: run_command(["gh", "pr", "edit", str(number), "--body", body])

                          # Semantisk Titel
                          clean_title = re.sub(r'[^a-zA-Z0-9 ]', '', title.replace("READY FOR MERGE", "")).strip()
                          if not re.match(r'^(feat|fix|docs|chore):', clean_title):
                              prefix = "fix" if "fix" in clean_title.lower() else "feat"
                              new_title = f"{prefix}: [{current_agent}] - {clean_title}"[:200]
                              run_command(["gh", "pr", "edit", str(number), "--title", new_title])

                          # Auto-Merge med AI konfliktlÃ¸sning
                          out, merge_err = run_command(["gh", "pr", "merge", str(number), "--squash", "--auto", "--delete-branch"])
                          if merge_err and "conflict" in merge_err:
                              consult_lifeline(merge_err, f"Merge PR #{number}")

                      except Exception: continue

              # === 2. DRIFT & SELF-HEALING ===
              print("\n--- 2. System Health Check ---")
              output, err = run_command(["gh", "run", "list", "--branch", "main", "--limit", "1", "--json", "databaseId,status,conclusion,headSha"])
              
              if output:
                  runs = json.loads(output)
                  if runs and runs[0]['status'] == "completed" and runs[0]['conclusion'] == "failure":
                      latest = runs[0]
                      run_id = latest['databaseId']
                      print(f"ğŸš¨ KRITISK FEJL PÃ… MAIN (Run {run_id})")

                      # Check hukommelse / Auto-heal
                      commits_out, _ = run_command(["git", "log", "-1", "--pretty=%B"])
                      if "chore(brain)" not in commits_out and "fix: auto-healing" not in commits_out:
                          log_out, _ = run_command(["gh", "run", "view", str(run_id), "--log-failed"])
                          error_snippet = log_out[-2000:] if log_out else "Unknown Error"
                          
                          print("ğŸš‘ ForsÃ¸ger auto-repair...")
                          if consult_lifeline(error_snippet, "Build Repair"):
                              # Fix virkede! Commit det
                              run_command(["git", "add", "."])
                              run_command(["git", "commit", "-m", f"fix: auto-healing build error {run_id}"])
                              run_command(["git", "push", "origin", "main"])
                              print("âœ… Auto-healing pushet.")
                          else:
                              # Fix fejlede -> Rollback
                              print("âš ï¸ Auto-heal fejlede. Starter Rollback.")
                              run_command(["git", "fetch", "origin", "main"])
                              run_command(["git", "checkout", "main"])
                              run_command(["git", "pull", "origin", "main"])
                              revert_out, revert_err = run_command(["git", "revert", latest['headSha'], "--no-edit"])
                              
                              if revert_err:
                                   if not consult_lifeline(revert_err, "Rollback Conflict"):
                                       raise Exception("Rollback Failed")
                              
                              run_command(["git", "push", "origin", "main"])
                              print("âœ… Rollback udfÃ¸rt.")
                              run_command(["gh", "issue", "create", "--title", f"ğŸ›¡ï¸ Auto-Rollback", "--body", f"Reverted commit {latest['headSha']}", "--label", "urgent"])

              print("âœ… Cyklus fÃ¦rdig.")

          except Exception as e:
              print(f"ğŸ”¥ FATAL: {e}")
              sys.exit(1)

      - name: ğŸ“ TODO Scanner
        uses: alstr/todo-to-issue-action@v4
        continue-on-error: true
        with:
          CLOSE_ISSUES: true
          AUTO_ASSIGN: true
          IGNORE: '/.github/workflows/*.yml, *.json' # Ignorerer ogsÃ¥ hukommelsesfilen
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: ğŸ†˜ NÃ¸d-mail
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "ğŸ”¥ HansPedder: Hukommelsen svigtede"
          to: clauskraft@gmail.com
          from: "HansPedder Orchestrator"
          body: |
            Log: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
