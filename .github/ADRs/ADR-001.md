# ADR-001: Phase 1.B Architecture Decisions

**Status**: PENDING ChiefArchitect decisions
**Date**: 2025-11-16
**Deciders**: ChiefArchitect (Autonomous Authority)

---

## DECISION 1: Multi-Monitor Architecture

### Context

WidgetBoard must support multiple monitor setups with persistent widget state across displays.

### Decision

**APPROVED: Portal-Based Architecture**

- React Portal per monitor enables isolated rendering
- Unified state management through Context API
- Scales efficiently for 2-6 monitor typical usage
- Proven pattern in multi-window applications

### Rationale

- Cleaner than monolithic canvas (easier to debug)
- More performant than service worker pattern for typical use
- Aligns with React best practices
- Handles monitor disconnect/reconnect gracefully

### Consequences

- Require React Portal library setup
- State sync complexity manageable with Context
- Performance implications: ~2-5% memory overhead per portal
- Testing requires multi-window test harness

---

## DECISION 2: Collaboration Sync Method

### Context

Multiple users editing same dashboard must see real-time updates without conflicts.

### Decision

**APPROVED: WebSocket-Based Real-Time Sync**

- WebSocket for low-latency bidirectional communication
- Operational transformation (OT) for conflict resolution
- Heartbeat/ping-pong for connection health
- Redis pub/sub for backend message routing

### Rationale

- Low latency (<100ms for most operations)
- Well-established conflict resolution patterns
- Scales horizontally with Redis
- Better than polling for collaboration scenarios

### Consequences

- WebSocket infrastructure required
- Conflict resolution complexity (OT implementation)
- Network resilience code needed
- Testing requires concurrent user simulation

---

## DECISION 3: Drag/Drop Library

### Context

Widgets must be draggable within dashboard with smooth UX.

### Decision

**CHOSEN: [ARCHITECT TO SELECT]**

### Options Considered

1. **react-beautiful-dnd** (Recommended)
   - Excellent accessibility (WCAG 2.1 AA compliant)
   - Smooth animations
   - Production-tested
   - Supports grid layouts

2. **React Grid Layout**
   - Built-in grid support
   - Responsive design
   - Persistent layout
   - Slightly heavier bundle

### Rationale

[ARCHITECT TO DOCUMENT]

### Consequences

[ARCHITECT TO DOCUMENT]

---

## DECISION 4: State Management Pattern

### Context

Dashboard state must be: Centralized, Predictable, Debuggable, Scalable to 50+ widgets

### Decision

**CHOSEN: [ARCHITECT TO SELECT]**

### Options Considered

1. **React Context + useReducer** (Lightweight)
   - Zero dependencies
   - Built-in to React
   - Good for moderate complexity
   - Less performance optimization

2. **Redux** (Enterprise)
   - Mature ecosystem
   - DevTools integration
   - Middleware support
   - Learning curve

3. **Zustand** (Modern)
   - Simple API
   - Minimal boilerplate
   - Good performance
   - Growing ecosystem

### Rationale

[ARCHITECT TO DOCUMENT]

### Consequences

[ARCHITECT TO DOCUMENT]

---

## DECISION 5: Layout Persistence Strategy

### Context

Widget positions, sizes, visibility must persist across sessions and browser restarts.

### Decision

**APPROVED: Hybrid LocalStorage + Server-Side Sync**

- LocalStorage for immediate persistence (instant load)
- Server-side database backup (reliability)
- Conflict resolution: Server-side version wins on sync
- Auto-save every 5 seconds

### Rationale

- Fast UX with LocalStorage immediate loading
- Data safety with server backup
- Clear conflict resolution strategy
- Bandwidth efficient (delta sync)

### Consequences

- Storage quota constraints (LocalStorage ~5-10MB)
- Sync conflicts possible (resolved server-side)
- Network dependency for persistence reliability
- Offline support requires careful queue management

---

## Summary

| Decision         | Choice                | Status               |
| ---------------- | --------------------- | -------------------- |
| Multi-Monitor    | Portal-Based          | ✅ APPROVED          |
| Collaboration    | WebSocket + OT        | ✅ APPROVED          |
| Drag/Drop        | [PENDING]             | ⏳ ARCHITECT DECIDES |
| State Management | [PENDING]             | ⏳ ARCHITECT DECIDES |
| Persistence      | LocalStorage + Server | ✅ APPROVED          |

## Implementation Timeline

- **Week 1 (Nov 18-22)**: Architecture validation with team
- **Week 2 (Nov 25-29)**: Proof-of-concept implementation
- **Dec 1-15**: Full Phase 1.B implementation
- **Dec 16-20**: Phase 1.C integration and testing

## Next Steps

1. ✅ ChiefArchitect: Finalize decisions 3 & 4 above
2. ✅ ChiefArchitect: Create ADR-001 with final decisions
3. ✅ ChiefArchitect: Present to team for feedback (Mon Nov 18)
4. → Team implementation begins Dec 1
